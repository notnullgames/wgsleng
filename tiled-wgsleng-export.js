/*
 * Tiled Map Exporter for wgsleng
 *
 * Exports Tiled maps to wgsleng format:
 * - Map layers as PNG textures (tile IDs stored in red channel)
 * - WGSL helper file with map metadata and helper functions
 *
 * Installation:
 * 1. Open Tiled
 * 2. Go to Edit > Preferences > Plugins
 * 3. Click "Open" to open the extensions directory
 * 4. Copy this file there
 * 5. Restart Tiled
 *
 * Usage:
 * File > Export As > wgsleng format (*.wgsl)
 */

var wgslengFormat = {
    name: "wgsleng format",
    extension: "wgsl",

    write: function(map, fileName) {
        const fs = new TextFile(fileName, TextFile.WriteOnly);
        const baseName = FileInfo.baseName(fileName);
        const dirPath = FileInfo.path(fileName);

        // Collect all unique tilesets
        const tilesets = [];
        const tilesetMap = new Map();

        for (let i = 0; i < map.tilesetCount; i++) {
            const tileset = map.tilesetAt(i);
            if (tileset.image) {
                const imageFileName = FileInfo.fileName(tileset.image);
                tilesets.push({
                    name: tileset.name,
                    image: imageFileName,
                    tileWidth: tileset.tileWidth,
                    tileHeight: tileset.tileHeight,
                    firstGid: tileset.firstGlobalTileId,
                    tileCount: tileset.tileCount,
                    columns: tileset.columns,
                    imageWidth: tileset.imageWidth,
                    imageHeight: tileset.imageHeight
                });
                tilesetMap.set(tileset.firstGlobalTileId, tilesets.length - 1);
            }
        }

        // Export each tile layer as a PNG texture
        const layers = [];
        for (let i = 0; i < map.layerCount; i++) {
            const layer = map.layerAt(i);
            if (layer.isTileLayer) {
                const layerName = layer.name.replace(/[^a-zA-Z0-9_]/g, '_');
                const pngFileName = baseName + "_" + layerName + ".png";
                const pngPath = dirPath + "/" + pngFileName;

                // Create an image to store tile IDs
                // We use R channel for tile ID (0-255)
                // For maps with >255 tiles, we could use RG (0-65535)
                const image = new Image(layer.width, layer.height, Image.Format_RGBA8888);

                for (let y = 0; y < layer.height; y++) {
                    for (let x = 0; x < layer.width; x++) {
                        const tile = layer.tileAt(x, y);
                        const tileId = tile ? tile.id : 0;
                        const gid = tile ? layer.cellAt(x, y).tileId : 0;

                        // Store tile ID in red channel
                        // If gid is 0, it's empty
                        const value = gid & 0xFF;
                        image.setPixelColor(x, y, Qt.rgba(value / 255.0, 0, 0, 1));
                    }
                }

                if (!image.save(pngPath)) {
                    tiled.error("Failed to save layer texture: " + pngPath);
                }

                layers.push({
                    name: layerName,
                    texture: pngFileName,
                    width: layer.width,
                    height: layer.height,
                    visible: layer.visible,
                    opacity: layer.opacity
                });
            }
        }

        // Generate WGSL helper file
        fs.writeLine("// Generated by wgsleng Tiled exporter");
        fs.writeLine("// Map: " + map.property("name") || baseName);
        fs.writeLine("");

        // Map constants
        fs.writeLine("// Map dimensions");
        fs.writeLine("const MAP_WIDTH: u32 = " + map.width + "u;");
        fs.writeLine("const MAP_HEIGHT: u32 = " + map.height + "u;");
        fs.writeLine("const TILE_WIDTH: f32 = " + map.tileWidth + ".0;");
        fs.writeLine("const TILE_HEIGHT: f32 = " + map.tileHeight + ".0;");
        fs.writeLine("");

        // Tileset information
        if (tilesets.length > 0) {
            fs.writeLine("// Tilesets");
            fs.writeLine("struct TilesetInfo {");
            fs.writeLine("    tile_width: f32,");
            fs.writeLine("    tile_height: f32,");
            fs.writeLine("    columns: u32,");
            fs.writeLine("    first_gid: u32,");
            fs.writeLine("    tile_count: u32,");
            fs.writeLine("    tex_width: f32,");
            fs.writeLine("    tex_height: f32,");
            fs.writeLine("}");
            fs.writeLine("");

            for (let i = 0; i < tilesets.length; i++) {
                const ts = tilesets[i];
                const varName = "tileset_" + ts.name.replace(/[^a-zA-Z0-9_]/g, '_');
                fs.writeLine("const " + varName + " = TilesetInfo(");
                fs.writeLine("    " + ts.tileWidth + ".0,");
                fs.writeLine("    " + ts.tileHeight + ".0,");
                fs.writeLine("    " + ts.columns + "u,");
                fs.writeLine("    " + ts.firstGid + "u,");
                fs.writeLine("    " + ts.tileCount + "u,");
                fs.writeLine("    " + ts.imageWidth + ".0,");
                fs.writeLine("    " + ts.imageHeight + ".0");
                fs.writeLine(");");
            }
            fs.writeLine("");
        }

        // Helper function to get tile ID from map texture
        fs.writeLine("// Get tile ID from map layer texture at tile coordinates");
        fs.writeLine("fn get_tile_id(map_tex: texture_2d<f32>, tile_x: u32, tile_y: u32) -> u32 {");
        fs.writeLine("    let pixel = textureLoad(map_tex, vec2u(tile_x, tile_y), 0);");
        fs.writeLine("    return u32(pixel.r * 255.0);");
        fs.writeLine("}");
        fs.writeLine("");

        // Helper function to get tile UV from tileset
        fs.writeLine("// Get UV coordinates for a tile from tileset");
        fs.writeLine("fn get_tile_uv(tileset: TilesetInfo, tile_id: u32, local_uv: vec2f) -> vec2f {");
        fs.writeLine("    if (tile_id == 0u) { return vec2f(0.0); }");
        fs.writeLine("    let local_id = tile_id - tileset.first_gid;");
        fs.writeLine("    let tile_x = local_id % tileset.columns;");
        fs.writeLine("    let tile_y = local_id / tileset.columns;");
        fs.writeLine("    let uv_x = (f32(tile_x) + local_uv.x) * tileset.tile_width / tileset.tex_width;");
        fs.writeLine("    let uv_y = (f32(tile_y) + local_uv.y) * tileset.tile_height / tileset.tex_height;");
        fs.writeLine("    return vec2f(uv_x, uv_y);");
        fs.writeLine("}");
        fs.writeLine("");

        // Helper to convert world position to tile coordinates
        fs.writeLine("// Convert world position to tile coordinates");
        fs.writeLine("fn world_to_tile(world_pos: vec2f) -> vec2u {");
        fs.writeLine("    return vec2u(");
        fs.writeLine("        u32(world_pos.x / TILE_WIDTH),");
        fs.writeLine("        u32(world_pos.y / TILE_HEIGHT)");
        fs.writeLine("    );");
        fs.writeLine("}");
        fs.writeLine("");

        // Helper to convert tile coordinates to world position
        fs.writeLine("// Convert tile coordinates to world position (top-left corner)");
        fs.writeLine("fn tile_to_world(tile_pos: vec2u) -> vec2f {");
        fs.writeLine("    return vec2f(f32(tile_pos.x) * TILE_WIDTH, f32(tile_pos.y) * TILE_HEIGHT);");
        fs.writeLine("}");
        fs.writeLine("");

        // Layer information
        if (layers.length > 0) {
            fs.writeLine("// Layers");
            fs.writeLine("// Use these with @texture() to load the layer data");
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                fs.writeLine("// Layer: " + layer.name + " (" + layer.width + "x" + layer.height + ")");
                fs.writeLine("// Usage: let tile_id = get_tile_id(@texture(\"" + layer.texture + "\"), x, y);");
            }
            fs.writeLine("");
        }

        // Example usage
        fs.writeLine("// Example: Render a tile layer");
        fs.writeLine("// fn render_tile_at(screen_pos: vec2f, layer_tex: texture_2d<f32>, tileset_tex: texture_2d<f32>, tileset: TilesetInfo) -> vec4f {");
        fs.writeLine("//     let tile_coord = world_to_tile(screen_pos);");
        fs.writeLine("//     if (tile_coord.x >= MAP_WIDTH || tile_coord.y >= MAP_HEIGHT) {");
        fs.writeLine("//         return vec4f(0.0); // Outside map");
        fs.writeLine("//     }");
        fs.writeLine("//     let tile_id = get_tile_id(layer_tex, tile_coord.x, tile_coord.y);");
        fs.writeLine("//     if (tile_id == 0u) {");
        fs.writeLine("//         return vec4f(0.0); // Empty tile");
        fs.writeLine("//     }");
        fs.writeLine("//     let tile_offset = fract(screen_pos / vec2f(TILE_WIDTH, TILE_HEIGHT));");
        fs.writeLine("//     let uv = get_tile_uv(tileset, tile_id, tile_offset);");
        fs.writeLine("//     return textureSampleLevel(tileset_tex, @engine.sampler, uv, 0.0);");
        fs.writeLine("// }");

        fs.commit();

        tiled.log("Exported map to " + fileName);
        tiled.log("Generated " + layers.length + " layer texture(s)");
        return true;
    }
};

tiled.registerMapFormat("wgsleng", wgslengFormat);
