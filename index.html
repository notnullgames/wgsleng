<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WGSL Shader Game</title>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #000;
      }
      canvas {
        max-width: 100%;
        max-height: 100vh;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        color: white;
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <div id="info">Arrow keys or WASD to move</div>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script type="module">
      const canvas = document.getElementById("canvas");
      const adapter = await navigator.gpu?.requestAdapter();
      if (!adapter) {
        alert("WebGPU not supported");
        throw new Error("No WebGPU");
      }

      const device = await adapter.requestDevice();
      const context = canvas.getContext("webgpu");
      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({ device, format });

      // Input state
      const buttons = new Uint32Array(12);
      const keyMap = {
        ArrowUp: 0,
        w: 0,
        W: 0,
        ArrowDown: 1,
        s: 1,
        S: 1,
        ArrowLeft: 2,
        a: 2,
        A: 2,
        ArrowRight: 3,
        d: 3,
        D: 3,
      };

      addEventListener("keydown", (e) => {
        if (keyMap[e.key] !== undefined) {
          buttons[keyMap[e.key]] = 1;
          e.preventDefault();
        }
      });
      addEventListener("keyup", (e) => {
        if (keyMap[e.key] !== undefined) {
          buttons[keyMap[e.key]] = 0;
          e.preventDefault();
        }
      });

      // Load shader
      const code = await fetch("game.wgsl").then((r) => r.text());
      const module = device.createShaderModule({ code });

      // Load texture
      const img = await createImageBitmap(
        await fetch("player.png").then((r) => r.blob()),
      );
      const texture = device.createTexture({
        size: [img.width, img.height],
        format: "rgba8unorm",
        usage:
          GPUTextureUsage.TEXTURE_BINDING |
          GPUTextureUsage.COPY_DST |
          GPUTextureUsage.RENDER_ATTACHMENT,
      });
      device.queue.copyExternalImageToTexture({ source: img }, { texture }, [
        img.width,
        img.height,
      ]);

      const sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear",
      });

      // Buffers
      const inputBuffer = device.createBuffer({
        size: 64,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      const stateBuffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(
        stateBuffer,
        0,
        new Float32Array([400, 300, 0, 0]),
      );

      // Pipelines with auto layout
      const computePipeline = device.createComputePipeline({
        layout: "auto",
        compute: { module, entryPoint: "update" },
      });

      const renderPipeline = device.createRenderPipeline({
        layout: "auto",
        vertex: { module, entryPoint: "vs_main" },
        fragment: { module, entryPoint: "fs_render", targets: [{ format }] },
        primitive: { topology: "triangle-list" },
      });

      // Bind groups - compute uses group 0
      const computeBindGroup = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: inputBuffer } },
          { binding: 1, resource: { buffer: stateBuffer } },
        ],
      });

      // Render uses group 0 (textures) and group 1 (state)
      const renderTextureBindGroup = device.createBindGroup({
        layout: renderPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: texture.createView() },
          { binding: 1, resource: sampler },
        ],
      });

      const renderStateBindGroup = device.createBindGroup({
        layout: renderPipeline.getBindGroupLayout(1),
        entries: [{ binding: 0, resource: { buffer: stateBuffer } }],
      });

      // Render loop
      // Render loop
      let last = performance.now();
      function frame() {
        const now = performance.now();
        const dt = (now - last) / 1000;
        last = now;

        // Create input data as Uint32 array view (12 u32 buttons + 4 f32 values)
        const inputData = new ArrayBuffer(64);
        const inputU32 = new Uint32Array(inputData);
        const inputF32 = new Float32Array(inputData);

        // Write buttons as u32 (indices 0-11)
        inputU32.set(buttons, 0);

        // Write time/delta/screen as f32 (indices 12-15)
        inputF32[12] = now / 1000;
        inputF32[13] = dt;
        inputF32[14] = canvas.width;
        inputF32[15] = canvas.height;

        device.queue.writeBuffer(inputBuffer, 0, inputData);

        const encoder = device.createCommandEncoder();

        const compute = encoder.beginComputePass();
        compute.setPipeline(computePipeline);
        compute.setBindGroup(0, computeBindGroup);
        compute.dispatchWorkgroups(1);
        compute.end();

        const render = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        });
        render.setPipeline(renderPipeline);
        render.setBindGroup(0, renderTextureBindGroup);
        render.setBindGroup(1, renderStateBindGroup);
        render.draw(3);
        render.end();

        device.queue.submit([encoder.finish()]);
        requestAnimationFrame(frame);
      }
      frame();
    </script>
  </body>
</html>
