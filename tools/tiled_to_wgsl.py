#!/usr/bin/env python3

"""
Tiled to WGSL Converter

Converts Tiled JSON maps (.tmj) to efficient texture-based format for wgsleng:
- Map layers as PNG textures (tile IDs encoded in pixels)
- WGSL helper file with map metadata and functions

Usage:
    python tiled_to_wgsl.py path/to/map.tmj [output_dir]

Requirements:
    pip install Pillow
"""

import json
import sys
import os
from pathlib import Path
try:
    from PIL import Image
except ImportError:
    print("Error: Pillow is required. Install with: pip install Pillow")
    sys.exit(1)


def load_tilemap(tmj_path):
    """Load and parse a Tiled JSON map file."""
    with open(tmj_path, 'r') as f:
        return json.load(f)


def create_layer_texture(layer_data, width, height, max_tile_id):
    """
    Create a PNG texture encoding tile IDs.

    For tile IDs 0-255: Use R channel
    For tile IDs 256-65535: Use R and G channels (R = low byte, G = high byte)
    """
    # Determine if we need 2 channels
    use_two_channels = max_tile_id > 255

    # Create image (RGBA format)
    img = Image.new('RGBA', (width, height), (0, 0, 0, 255))
    pixels = img.load()

    for y in range(height):
        for x in range(width):
            idx = y * width + x
            tile_id = layer_data[idx] if idx < len(layer_data) else 0

            if use_two_channels:
                # Split into low and high bytes
                r = tile_id & 0xFF
                g = (tile_id >> 8) & 0xFF
                pixels[x, y] = (r, g, 0, 255)
            else:
                # Single channel
                pixels[x, y] = (tile_id, 0, 0, 255)

    return img, use_two_channels


def sanitize_name(name):
    """Convert a name to a valid WGSL identifier."""
    import re
    return re.sub(r'[^a-zA-Z0-9_]', '_', name).upper()


def generate_wgsl(map_data, map_name, layers_info, tilesets, output_path):
    """Generate WGSL helper file with map metadata and functions."""

    map_name_upper = sanitize_name(map_name)

    lines = []
    lines.append("// Generated by tiled_to_wgsl.py")
    lines.append(f"// Map: {map_name}")
    lines.append("")

    # Map constants
    lines.append(f"// Map dimensions for {map_name}")
    lines.append(f"const {map_name_upper}_WIDTH: u32 = {map_data['width']}u;")
    lines.append(f"const {map_name_upper}_HEIGHT: u32 = {map_data['height']}u;")
    lines.append(f"const {map_name_upper}_TILE_WIDTH: f32 = {map_data['tilewidth']}.0;")
    lines.append(f"const {map_name_upper}_TILE_HEIGHT: f32 = {map_data['tileheight']}.0;")
    lines.append("")

    # Tileset info struct (only once)
    if tilesets:
        lines.append("// Tileset information")
        lines.append("struct TilesetInfo {")
        lines.append("    tile_width: f32,")
        lines.append("    tile_height: f32,")
        lines.append("    columns: u32,")
        lines.append("    first_gid: u32,")
        lines.append("    tile_count: u32,")
        lines.append("    tex_width: f32,")
        lines.append("    tex_height: f32,")
        lines.append("}")
        lines.append("")

        # Tileset constants
        for ts in tilesets:
            ts_name = sanitize_name(ts['name'])
            lines.append(f"const {map_name_upper}_TILESET_{ts_name} = TilesetInfo(")
            lines.append(f"    {ts['tilewidth']}.0,")
            lines.append(f"    {ts['tileheight']}.0,")
            lines.append(f"    {ts['columns']}u,")
            lines.append(f"    {ts['firstgid']}u,")
            lines.append(f"    {ts['tilecount']}u,")
            lines.append(f"    {ts['imagewidth']}.0,")
            lines.append(f"    {ts['imageheight']}.0")
            lines.append(");")
            lines.append(f"// Load with: @texture(\"{ts['image']}\")")
            lines.append("")

    # Layer texture references
    if layers_info:
        lines.append("// Map layer textures")
        for layer_name, texture_file, use_two_channels in layers_info:
            layer_name_upper = sanitize_name(layer_name)
            channels = "RG" if use_two_channels else "R"
            lines.append(f"// {layer_name}: Load with @texture(\"{texture_file}\") - Tile IDs in {channels} channel(s)")
        lines.append("")

    # Helper functions
    lines.append("// Get tile ID from map texture at tile coordinates")

    # Single channel version
    lines.append(f"fn {map_name_upper}_get_tile(map_tex: texture_2d<f32>, x: u32, y: u32) -> u32 {{")
    lines.append(f"    if (x >= {map_name_upper}_WIDTH || y >= {map_name_upper}_HEIGHT) {{ return 0u; }}")
    lines.append("    let pixel = textureLoad(map_tex, vec2u(x, y), 0);")
    lines.append("    return u32(pixel.r * 255.0);")
    lines.append("}")
    lines.append("")

    # Two channel version for maps with >255 tiles
    lines.append(f"fn {map_name_upper}_get_tile_16bit(map_tex: texture_2d<f32>, x: u32, y: u32) -> u32 {{")
    lines.append(f"    if (x >= {map_name_upper}_WIDTH || y >= {map_name_upper}_HEIGHT) {{ return 0u; }}")
    lines.append("    let pixel = textureLoad(map_tex, vec2u(x, y), 0);")
    lines.append("    let low = u32(pixel.r * 255.0 + 0.5);")
    lines.append("    let high = u32(pixel.g * 255.0 + 0.5);")
    lines.append("    return low | (high << 8u);")
    lines.append("}")
    lines.append("")

    # Get tile UV from tileset
    lines.append("// Get UV coordinates for a tile from tileset")
    lines.append(f"fn {map_name_upper}_get_tile_uv(tileset: TilesetInfo, tile_id: u32, local_uv: vec2f) -> vec2f {{")
    lines.append("    if (tile_id == 0u) { return vec2f(0.0); }")
    lines.append("    let local_id = tile_id - tileset.first_gid;")
    lines.append("    let tile_x = local_id % tileset.columns;")
    lines.append("    let tile_y = local_id / tileset.columns;")
    lines.append("    let uv_x = (f32(tile_x) + local_uv.x) * tileset.tile_width / tileset.tex_width;")
    lines.append("    let uv_y = (f32(tile_y) + local_uv.y) * tileset.tile_height / tileset.tex_height;")
    lines.append("    return vec2f(uv_x, uv_y);")
    lines.append("}")
    lines.append("")

    # World/tile coordinate conversion
    lines.append("// Convert world position to tile coordinates")
    lines.append(f"fn {map_name_upper}_world_to_tile(world_pos: vec2f) -> vec2u {{")
    lines.append("    return vec2u(")
    lines.append(f"        u32(world_pos.x / {map_name_upper}_TILE_WIDTH),")
    lines.append(f"        u32(world_pos.y / {map_name_upper}_TILE_HEIGHT)")
    lines.append("    );")
    lines.append("}")
    lines.append("")

    lines.append("// Convert tile coordinates to world position (top-left corner)")
    lines.append(f"fn {map_name_upper}_tile_to_world(tile_pos: vec2u) -> vec2f {{")
    lines.append(f"    return vec2f(f32(tile_pos.x) * {map_name_upper}_TILE_WIDTH, f32(tile_pos.y) * {map_name_upper}_TILE_HEIGHT);")
    lines.append("}")
    lines.append("")

    # Example usage
    lines.append("// Example: Render a tile from a layer")
    lines.append("// fn render_tile(screen_pos: vec2f, layer_tex: texture_2d<f32>, tileset_tex: texture_2d<f32>, tileset: TilesetInfo) -> vec4f {")
    lines.append(f"//     let tile_coord = {map_name_upper}_world_to_tile(screen_pos);")
    lines.append(f"//     let tile_id = {map_name_upper}_get_tile(layer_tex, tile_coord.x, tile_coord.y);")
    lines.append("//     if (tile_id == 0u) { return vec4f(0.0); }")
    lines.append(f"//     let tile_offset = fract(screen_pos / vec2f({map_name_upper}_TILE_WIDTH, {map_name_upper}_TILE_HEIGHT));")
    lines.append(f"//     let uv = {map_name_upper}_get_tile_uv(tileset, tile_id, tile_offset);")
    lines.append("//     return textureSampleLevel(tileset_tex, @engine.sampler, uv, 0.0);")
    lines.append("// }")

    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))


def process_tilemap(tmj_path, output_dir=None):
    """Process a Tiled JSON map and generate textures + WGSL."""

    tmj_path = Path(tmj_path)
    if not tmj_path.exists():
        print(f"Error: File not found: {tmj_path}")
        return False

    # Determine output directory
    if output_dir is None:
        output_dir = tmj_path.parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

    map_name = tmj_path.stem
    print(f"Processing: {tmj_path}")
    print(f"Output directory: {output_dir}")

    # Load map
    map_data = load_tilemap(tmj_path)

    # Process tilesets
    tilesets = []
    if 'tilesets' in map_data:
        for ts in map_data['tilesets']:
            # Handle external tilesets
            if 'source' in ts:
                # Load external tileset
                ts_path = tmj_path.parent / ts['source']
                with open(ts_path, 'r') as f:
                    ts_data = json.load(f)
                    ts_data['firstgid'] = ts['firstgid']
                    tilesets.append(ts_data)
            else:
                tilesets.append(ts)

    # Find max tile ID across all layers
    max_tile_id = 0
    for layer in map_data.get('layers', []):
        if layer.get('type') == 'tilelayer' and 'data' in layer:
            layer_max = max(layer['data'])
            max_tile_id = max(max_tile_id, layer_max)

    print(f"Map size: {map_data['width']}x{map_data['height']}")
    print(f"Tile size: {map_data['tilewidth']}x{map_data['tileheight']}")
    print(f"Max tile ID: {max_tile_id}")
    print(f"Channels needed: {'RG (16-bit)' if max_tile_id > 255 else 'R (8-bit)'}")

    # Process layers
    layers_info = []
    for layer in map_data.get('layers', []):
        if layer.get('type') == 'tilelayer':
            layer_name = layer['name']
            layer_data = layer.get('data', [])
            width = layer['width']
            height = layer['height']

            print(f"\nProcessing layer: {layer_name} ({width}x{height})")

            # Create texture
            img, use_two_channels = create_layer_texture(layer_data, width, height, max_tile_id)

            # Save texture
            texture_filename = f"{map_name}_{layer_name}.png"
            texture_path = output_dir / texture_filename
            img.save(texture_path)
            print(f"  Saved: {texture_filename}")

            layers_info.append((layer_name, texture_filename, use_two_channels))

    # Generate WGSL
    wgsl_path = output_dir / f"{map_name}.wgsl"
    generate_wgsl(map_data, map_name, layers_info, tilesets, wgsl_path)
    print(f"\nGenerated: {wgsl_path.name}")

    print("\nâœ“ Conversion complete!")
    print(f"\nUsage in your game:")
    print(f'  @import("{map_name}.wgsl")')

    return True


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    tmj_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) > 2 else None

    if not process_tilemap(tmj_path, output_dir):
        sys.exit(1)


if __name__ == '__main__':
    main()
