# Practical 3D Rendering - Design

## Overview

Extend the engine to support traditional triangle-based 3D rendering using vertex buffers and model loading.

## Syntax

```wgsl
// Reference a model file (OBJ, glTF, etc.)
@model("cube.obj")

// Access in vertex shader
@vertex
fn vs_main(@location(0) position: vec3f,
           @location(1) normal: vec3f,
           @location(2) uv: vec2f,
           @builtin(vertex_index) vertex_id: u32,
           @builtin(instance_index) instance_id: u32) -> VertexOutput {
    // Transform vertices
}

// Or access buffer directly for custom layouts
@vertex
fn vs_main(@builtin(vertex_index) idx: u32) -> VertexOutput {
    let pos = @model("cube.obj").positions[idx];
    let normal = @model("cube.obj").normals[idx];
    let uv = @model("cube.obj").uvs[idx];
}
```

## Host Implementation

### Preprocessing (similar to `@texture`)

1. **Parse WGSL** - Find `@model("filename")` directives
2. **Load model file** - Parse OBJ/glTF/etc.
3. **Create vertex buffers** - Upload to GPU
4. **Generate bindings** - Create `@group(X) @binding(Y)` for buffers
5. **Replace references** - `@model("cube.obj")` → `_model_0`

### Model Data Structure

```rust
struct ModelData {
    positions: Vec<[f32; 3]>,
    normals: Vec<[f32; 3]>,
    uvs: Vec<[f32; 2]>,
    indices: Option<Vec<u32>>,
    vertex_count: u32,
}
```

### Injected Buffers

```wgsl
// Auto-generated by preprocessor
struct ModelPositions {
    data: array<vec3f>
}
@group(1) @binding(0) var<storage> _model_0_positions: ModelPositions;

struct ModelNormals {
    data: array<vec3f>
}
@group(1) @binding(1) var<storage> _model_0_normals: ModelNormals;

struct ModelUVs {
    data: array<vec2f>
}
@group(1) @binding(2) var<storage> _model_0_uvs: ModelUVs;

// User's access is replaced:
// @model("cube.obj").positions[idx] → _model_0_positions.data[idx]
```

## File Format Support

### Phase 1 - OBJ
- Simple ASCII format
- Widely supported
- Easy to parse
- Supports: positions, normals, UVs

### Phase 2 - glTF
- Industry standard
- Binary format (faster)
- Supports: animations, materials, PBR
- More complex to parse

### Phase 3 - Procedural
- Built-in primitives: cube, sphere, cylinder
- `@model("primitive:cube")`

## Example Usage

```wgsl
@set_title("3D Model Demo")
@set_size(800, 600)

@model("character.obj")
@texture("character.png")

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) world_pos: vec3f,
    @location(1) normal: vec3f,
    @location(2) uv: vec2f,
}

@vertex
fn vs_main(@builtin(vertex_index) idx: u32) -> VertexOutput {
    let pos = @model("character.obj").positions[idx];
    let normal = @model("character.obj").normals[idx];
    let uv = @model("character.obj").uvs[idx];

    // Transform to world space
    let world_pos = model_matrix * vec4f(pos, 1.0);

    // Transform to clip space
    let clip_pos = projection * view * world_pos;

    return VertexOutput(clip_pos, world_pos.xyz, normal, uv);
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4f {
    // Sample texture
    let albedo = textureSample(@texture("character.png"), @engine.sampler, in.uv);

    // Lighting
    let light_dir = normalize(vec3f(1.0, 1.0, -1.0));
    let diffuse = max(dot(in.normal, light_dir), 0.0);

    return vec4f(albedo.rgb * diffuse, albedo.a);
}
```

## Advantages

- **Familiar workflow** - Standard vertex/fragment pipeline
- **Better performance** - Render triangles once, not per-pixel
- **Asset compatibility** - Use existing 3D models
- **Scalability** - Handle complex scenes with many objects
- **Traditional techniques** - Instancing, LOD, culling, etc.

## Implementation Steps

1. ✅ Design syntax and architecture
2. ⬜ Add OBJ parser to native/web hosts
3. ⬜ Extend preprocessor to handle `@model` directive
4. ⬜ Create vertex buffer management
5. ⬜ Update render pipeline to handle model data
6. ⬜ Create example with procedural cube (no file loading)
7. ⬜ Create example with loaded OBJ file
8. ⬜ Add draw call management (multiple models, instancing)
9. ⬜ Create 3D helper library (transforms, camera, lighting)
10. ⬜ Documentation and examples

## Comparison: Ray Marching vs Traditional

| Feature | Ray Marching | Traditional |
|---------|-------------|-------------|
| **Performance** | Per-pixel compute | Per-vertex/triangle |
| **Geometry** | Mathematical SDFs | Triangle meshes |
| **Assets** | Procedural only | Import from tools |
| **Complexity** | Simple shapes hard | Complex models easy |
| **Use case** | Demos, effects | Games, apps |
| **Lighting** | Built into march | Separate pass |
| **Scalability** | Limited | Excellent |

## Both Approaches

Keep both examples:
- `examples/3d/` - Ray marching (artistic, demos)
- `examples/3d_practical/` - Traditional rendering (games)
