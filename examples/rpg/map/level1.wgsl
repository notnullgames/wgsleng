// Generated by tiled_to_wgsl.py
// Map: level1

// Map dimensions for level1
const LEVEL1_WIDTH: u32 = 10u;
const LEVEL1_HEIGHT: u32 = 10u;
const LEVEL1_TILE_WIDTH: f32 = 16.0;
const LEVEL1_TILE_HEIGHT: f32 = 16.0;

// Tileset information
struct TilesetInfo {
    tile_width: f32,
    tile_height: f32,
    columns: u32,
    first_gid: u32,
    tile_count: u32,
    tex_width: f32,
    tex_height: f32,
}

const LEVEL1_TILESET_TILEA1 = TilesetInfo(
    16.0,
    16.0,
    16u,
    1u,
    192u,
    256.0,
    192.0
);
// Load with: @texture("tileA1.png")

const LEVEL1_TILESET_TILEA2 = TilesetInfo(
    16.0,
    16.0,
    16u,
    193u,
    192u,
    256.0,
    192.0
);
// Load with: @texture("tileA2.png")

const LEVEL1_TILESET_TILEB = TilesetInfo(
    16.0,
    16.0,
    16u,
    385u,
    256u,
    256.0,
    256.0
);
// Load with: @texture("tileB.png")

const LEVEL1_TILESET_HEROES = TilesetInfo(
    16.0,
    16.0,
    12u,
    641u,
    96u,
    192.0,
    128.0
);
// Load with: @texture("heroes.png")

// Map layer textures
// ground: Load with @texture("level1_ground.png") - Tile IDs in RG channel(s)
// stuff: Load with @texture("level1_stuff.png") - Tile IDs in RG channel(s)
// collisions: Load with @texture("level1_collisions.png") - Tile IDs in RG channel(s)

// Get tile ID from map texture at tile coordinates
fn LEVEL1_get_tile(map_tex: texture_2d<f32>, x: u32, y: u32) -> u32 {
    if (x >= LEVEL1_WIDTH || y >= LEVEL1_HEIGHT) { return 0u; }
    let pixel = textureLoad(map_tex, vec2u(x, y), 0);
    return u32(pixel.r * 255.0);
}

fn LEVEL1_get_tile_16bit(map_tex: texture_2d<f32>, x: u32, y: u32) -> u32 {
    if (x >= LEVEL1_WIDTH || y >= LEVEL1_HEIGHT) { return 0u; }
    // Use textureLoad with exact pixel coordinates (no interpolation)
    let pixel = textureLoad(map_tex, vec2u(x, y), 0);
    let low = u32(pixel.r * 255.0 + 0.5);
    let high = u32(pixel.g * 255.0 + 0.5);
    return low | (high << 8u);
}

// Get UV coordinates for a tile from tileset
fn LEVEL1_get_tile_uv(tileset: TilesetInfo, tile_id: u32, local_uv: vec2f) -> vec2f {
    if (tile_id == 0u) { return vec2f(0.0); }
    let local_id = tile_id - tileset.first_gid;
    let tile_x = local_id % tileset.columns;
    let tile_y = local_id / tileset.columns;
    let uv_x = (f32(tile_x) + local_uv.x) * tileset.tile_width / tileset.tex_width;
    let uv_y = (f32(tile_y) + local_uv.y) * tileset.tile_height / tileset.tex_height;
    return vec2f(uv_x, uv_y);
}

// Convert world position to tile coordinates
fn LEVEL1_world_to_tile(world_pos: vec2f) -> vec2u {
    return vec2u(
        u32(world_pos.x / LEVEL1_TILE_WIDTH),
        u32(world_pos.y / LEVEL1_TILE_HEIGHT)
    );
}

// Convert tile coordinates to world position (top-left corner)
fn LEVEL1_tile_to_world(tile_pos: vec2u) -> vec2f {
    return vec2f(f32(tile_pos.x) * LEVEL1_TILE_WIDTH, f32(tile_pos.y) * LEVEL1_TILE_HEIGHT);
}

// Example: Render a tile from a layer
// fn render_tile(screen_pos: vec2f, layer_tex: texture_2d<f32>, tileset_tex: texture_2d<f32>, tileset: TilesetInfo) -> vec4f {
//     let tile_coord = LEVEL1_world_to_tile(screen_pos);
//     let tile_id = LEVEL1_get_tile(layer_tex, tile_coord.x, tile_coord.y);
//     if (tile_id == 0u) { return vec4f(0.0); }
//     let tile_offset = fract(screen_pos / vec2f(LEVEL1_TILE_WIDTH, LEVEL1_TILE_HEIGHT));
//     let uv = LEVEL1_get_tile_uv(tileset, tile_id, tile_offset);
//     return textureSampleLevel(tileset_tex, @engine.sampler, uv, 0.0);
// }